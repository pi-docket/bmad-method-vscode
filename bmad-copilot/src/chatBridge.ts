/**
 * @fileoverview Chat Bridge ‚Äî Official BMAD GitHub Copilot Prompt Executor
 *
 * This module is the core of the BMAD Copilot Adapter. It reads
 * official `.prompt.md` / `.agent.md` files generated by the BMAD
 * installer and passes them **as-is** to the Copilot LLM.
 *
 * **Design Philosophy**
 *
 * - The adapter does NOT pre-read, inline, or transform file
 *   references inside prompt files. The official prompts contain
 *   `{project-root}` tokens that the LLM resolves through its
 *   own workspace context.
 * - For `install` and `status`, the real BMAD CLI is spawned via
 *   {@link CliBridge}.
 * - If `.github/prompts/` files are missing (i.e. BMAD was installed
 *   without `--tools github-copilot`), the legacy {@link BmadRuntime}
 *   fallback is used.
 *
 * @module chatBridge
 */

import * as vscode from 'vscode';
import * as fs from 'node:fs';
import * as path from 'node:path';
import { CommandRegistry } from './commandRegistry.js';
import { CliBridge } from './cliBridge.js';
import { BmadRuntime } from './bmadRuntime.js';
import { hasClaudeCodeSource } from './promptMirror.js';
import type { BmadCommand, RegistryState } from './types.js';

/* ------------------------------------------------------------------ */
/*  Constants                                                         */
/* ------------------------------------------------------------------ */

/** The missing-installation message, modelled after the official CLI. */
const MISSING_INSTALL_MESSAGE = `
‚ö†Ô∏è **BMAD installation not found**

No \`_bmad/\` directory detected in your workspace.

**Quick setup:**

\`\`\`bash
npx bmad-method install --tools github-copilot
\`\`\`

**Prerequisites:**
- Node.js **v20+** and npm
- Run the command above from your **project root**

**With specific modules:**

\`\`\`bash
npx bmad-method install --modules bmm --tools github-copilot --yes
\`\`\`

> Available modules: \`bmm\` (Business Model Master), \`bmb\` (BMad Builder), \`tea\` (Test Architect), \`gds\` (Game Dev Studio), \`cis\` (Creative Intelligence Suite)

After installation, reload the VS Code window or use \`@bmad /status\`.
`.trim();

/** Message when Copilot prompt files are missing but _bmad/ exists. */
const MISSING_COPILOT_FILES_MESSAGE = `
‚ö†Ô∏è **GitHub Copilot prompt files not found**

Your workspace has \`_bmad/\` but no \`.github/prompts/\` or \`.github/agents/\` BMAD files.

The adapter automatically mirrors prompt files from \`claude-code\` if available.
If both sources are missing, install BMAD with either tool:

**Option 1 ‚Äî claude-code (recommended, works without Cloud Code CLI):**
\`\`\`bash
npx bmad-method install --modules bmm --tools claude-code --yes
\`\`\`

**Option 2 ‚Äî github-copilot (native):**
\`\`\`bash
npx bmad-method install --modules bmm --tools github-copilot --yes
\`\`\`

> **Note:** Cloud Code CLI is NOT required. Only the generated prompt files are needed.

After installation, use \`@bmad /status\` to verify.
`.trim();

/* ------------------------------------------------------------------ */
/*  ChatBridge                                                        */
/* ------------------------------------------------------------------ */

/**
 * Bridges the VS Code Copilot Chat participant API with BMAD.
 *
 * ### Slash-command routing
 *
 * | Command      | Mode               | Behaviour                                 |
 * |--------------|--------------------|-------------------------------------------|
 * | `/status`    | Built-in + CLI     | Show installation status                  |
 * | `/install`   | CLI Bridge         | Open terminal with `npx bmad-method install` |
 * | `/help`      | Built-in           | List commands and help guidance            |
 * | `/run <cmd>` | Prompt Executor    | Read prompt file ‚Üí resolve refs ‚Üí LLM     |
 * | `/agents`    | Built-in           | List installed agents                      |
 * | `/workflows` | Built-in           | List installed workflows                   |
 * | `/tasks`     | Built-in           | List installed tasks and tools             |
 * | *(free text)*| Fuzzy ‚Üí Executor   | Match to command or BMAD context chat      |
 */
export class ChatBridge {
  private readonly registry: CommandRegistry;
  private readonly cliBridge: CliBridge;
  private readonly outputChannel: vscode.OutputChannel;

  /**
   * Active interactive CLI process. If set, the next user message in
   * chat will be piped to this process's stdin instead of being
   * treated as a new command.
   */
  private activeProcess: import('node:child_process').ChildProcess | null = null;

  constructor(
    registry: CommandRegistry,
    cliBridge: CliBridge,
    outputChannel: vscode.OutputChannel,
  ) {
    this.registry = registry;
    this.cliBridge = cliBridge;
    this.outputChannel = outputChannel;
  }

  /* -------------------------------------------------------------- */
  /*  Main handler                                                  */
  /* -------------------------------------------------------------- */

  /** The {@link vscode.ChatRequestHandler} implementation. */
  handler: vscode.ChatRequestHandler = async (
    request: vscode.ChatRequest,
    _context: vscode.ChatContext,
    stream: vscode.ChatResponseStream,
    token: vscode.CancellationToken,
  ): Promise<vscode.ChatResult> => {
    this.log(`command=${request.command ?? '(none)'} prompt="${request.prompt}"`);

    try {
      // --- If there's an active interactive process, pipe input ---
      if (this.activeProcess?.stdin && !this.activeProcess.killed) {
        this.activeProcess.stdin.write(request.prompt + '\n');
        stream.markdown(`üìù Sent: \`${request.prompt}\``);
        return {};
      }

      const state = this.registry.state;

      // --- Installation guard ---
      // Allow /status and /install to run even when state is null
      if (!state && request.command !== 'install' && request.command !== 'status') {
        stream.markdown(MISSING_INSTALL_MESSAGE);
        return {};
      }

      switch (request.command) {
        case 'install':
          return this.handleInstall(stream);
        case 'status':
          return this.handleStatus(state, stream);
        case 'help':
          return this.handleHelp(state!, request, stream, token);
        case 'run':
          return this.handleRun(state!, request, stream, token);
        case 'agents':
          return this.handleAgents(state!, stream);
        case 'workflows':
          return this.handleWorkflows(state!, stream);
        case 'tasks':
          return this.handleTasks(state!, stream);
        default:
          return this.handleFreeText(state!, request, stream, token);
      }
    } catch (err) {
      const msg = err instanceof Error ? err.message : String(err);
      this.log(`Error: ${msg}`);
      stream.markdown(`‚ùå **Error**: ${msg}`);
      return {};
    }
  };

  /* -------------------------------------------------------------- */
  /*  /install ‚Äî CLI Bridge                                          */
  /* -------------------------------------------------------------- */

  /**
   * Handle `/install` ‚Äî open a VS Code terminal running the real
   * BMAD CLI installer. The installer uses `@clack/prompts` for
   * interactive terminal UI, so it must run in a real TTY.
   */
  private handleInstall(stream: vscode.ChatResponseStream): vscode.ChatResult {
    const workspaceRoot = this.getWorkspaceRoot();

    stream.markdown(
      'üöÄ **Opening terminal to run BMAD installer‚Ä¶**\n\n' +
        'The installer will guide you through module and tool selection.\n\n' +
        '> **Tip:** To install non-interactively, run:\n' +
        '> ```bash\n' +
        '> npx bmad-method install --modules bmm --tools github-copilot --yes\n' +
        '> ```\n\n' +
        'After installation completes, use `@bmad /status` to verify.',
    );

    this.cliBridge.openTerminal(
      ['install', '--tools', 'github-copilot'],
      workspaceRoot,
    );

    return {};
  }

  /* -------------------------------------------------------------- */
  /*  /status ‚Äî Built-in + CLI version                               */
  /* -------------------------------------------------------------- */

  /**
   * Handle `/status` ‚Äî show BMAD installation health.
   *
   * Works even when `state` is null (no `_bmad/`), so the user can
   * diagnose installation problems.
   */
  private handleStatus(
    state: RegistryState | null,
    stream: vscode.ChatResponseStream,
  ): vscode.ChatResult {
    const workspaceRoot = this.getWorkspaceRoot();
    const hasBmad = this.cliBridge.hasBmadInstallation(workspaceRoot);
    const hasCopilot = this.cliBridge.hasCopilotPromptFiles(workspaceRoot);
    const hasClaudeCode = hasBmad && hasClaudeCodeSource(path.join(workspaceRoot, '_bmad'));

    const lines: string[] = ['# BMAD Installation Status\n'];

    lines.push(`| Check | Status |`);
    lines.push(`|---|---|`);
    lines.push(`| \`_bmad/\` directory | ${hasBmad ? '‚úÖ Found' : '‚ùå Missing'} |`);
    lines.push(`| GitHub Copilot prompt files | ${hasCopilot ? '‚úÖ Found' : '‚ö†Ô∏è Missing'} |`);
    lines.push(`| claude-code prompt source | ${hasClaudeCode ? '‚úÖ Available (auto-mirror)' : '‚ûñ Not found'} |`);
    lines.push(`| Workspace root | \`${workspaceRoot}\` |`);

    if (state) {
      lines.push(`| BMAD directory | \`${state.bmadDir}\` |`);
      lines.push(`| Installed modules | ${state.modules.join(', ') || 'none'} |`);
      lines.push(`| Discovered commands | ${state.commands.size} |`);
      lines.push(`| Prompt files mapped | ${state.promptFiles.size} |`);
      lines.push(`| Agents | ${state.agents.length} |`);
      lines.push(`| Workflows | ${state.workflows.length} |`);
      lines.push(`| Tasks | ${state.tasks.length} |`);
      lines.push(`| Tools | ${state.tools.length} |`);
      lines.push(`| Last scan | ${state.lastScan} |`);
    }

    lines.push('');

    if (!hasBmad) {
      lines.push('---\n');
      lines.push(MISSING_INSTALL_MESSAGE);
    } else if (!hasCopilot) {
      lines.push('---\n');
      lines.push(MISSING_COPILOT_FILES_MESSAGE);
    }

    stream.markdown(lines.join('\n'));
    return {};
  }

  /* -------------------------------------------------------------- */
  /*  /help ‚Äî List commands and guidance                             */
  /* -------------------------------------------------------------- */

  /**
   * Handle `/help` ‚Äî show available commands and usage guidance.
   * If the user provides a topic, filter or focus the help output.
   */
  private async handleHelp(
    state: RegistryState,
    request: vscode.ChatRequest,
    stream: vscode.ChatResponseStream,
    token: vscode.CancellationToken,
  ): Promise<vscode.ChatResult> {
    const topic = request.prompt.trim();

    // If user asks about a specific command, try to resolve it
    if (topic && topic.startsWith('bmad')) {
      const cmd = this.registry.resolve(topic);
      if (cmd) {
        stream.markdown(this.formatCommandDetail(cmd));
        return {};
      }
    }

    // Build help listing
    const lines: string[] = [
      '# BMAD Help\n',
      '## Quick Commands\n',
      '| Command | Description |',
      '|---|---|',
      '| `@bmad /status` | Check installation health |',
      '| `@bmad /install` | Run the BMAD installer (opens terminal) |',
      '| `@bmad /help` | This help message |',
      '| `@bmad /run <name>` | Execute a BMAD command |',
      '| `@bmad /agents` | List installed agents |',
      '| `@bmad /workflows` | List installed workflows |',
      '| `@bmad /tasks` | List installed tasks and tools |',
      '',
    ];

    // Top commands from help entries
    if (state.helpEntries.length > 0) {
      lines.push('## Available BMAD Commands\n');
      const byPhase = new Map<string, typeof state.helpEntries>();
      for (const h of state.helpEntries) {
        const phase = h.phase || 'anytime';
        if (!byPhase.has(phase)) byPhase.set(phase, []);
        byPhase.get(phase)!.push(h);
      }

      for (const [phase, entries] of byPhase) {
        lines.push(`### ${phase}\n`);
        lines.push('| Command | Name | Agent | Description |');
        lines.push('|---|---|---|---|');
        for (const h of entries) {
          const cmd = h.command ? `\`/run ${h.command}\`` : `*${h.code || '‚Äî'}*`;
          lines.push(`| ${cmd} | ${h.name} | ${h['agent-title'] || ''} | ${h.description} |`);
        }
        lines.push('');
      }
    }

    lines.push(
      '\n> **Tip:** You can also type a command name directly, e.g. ' +
        '`@bmad bmad-bmm-create-prd`\n',
    );

    // If user had a topic query, also send to LLM for contextual help
    if (topic) {
      lines.push(`\n---\n\n*Searching for help on: "${topic}"‚Ä¶*\n\n`);
      stream.markdown(lines.join('\n'));
      // Use LLM for contextual help
      const contextPrompt = [
        'You are a BMAD-METHOD expert assistant.',
        `Installed modules: ${state.modules.join(', ')}`,
        `Available commands: ${state.commands.size}`,
        `\nUser is asking for help about: ${topic}`,
        '\nProvide concise, actionable guidance. Suggest specific commands where applicable.',
      ].join('\n');
      return this.sendToLlm(contextPrompt, request, stream, token);
    }

    stream.markdown(lines.join('\n'));
    return {};
  }

  /* -------------------------------------------------------------- */
  /*  /run ‚Äî Prompt File Executor (core)                            */
  /* -------------------------------------------------------------- */

  /**
   * Handle `/run <command-name>` ‚Äî execute a BMAD command.
   *
   * **Execution strategy:**
   * 1. Resolve command from the registry.
   * 2. If an official `.prompt.md` or `.agent.md` file exists ‚Üí
   *    read it and send the prompt **as-is** to the LLM. The LLM
   *    resolves `{project-root}` references via its own workspace context.
   * 3. If no prompt file ‚Üí fall back to BmadRuntime prompt builder
   *    (reads from `_bmad/` directly).
   */
  private async handleRun(
    state: RegistryState,
    request: vscode.ChatRequest,
    stream: vscode.ChatResponseStream,
    token: vscode.CancellationToken,
  ): Promise<vscode.ChatResult> {
    const parts = request.prompt.trim().split(/\s+/);
    const rawName = parts[0] || '';
    const userInput = parts.slice(1).join(' ');

    if (!rawName) {
      stream.markdown(
        'üí° **Usage:** `/run <command-name> [input]`\n\n' +
          'Examples:\n' +
          '- `/run bmad-bmm-create-prd`\n' +
          '- `/run bmad-agent-bmm-pm`\n\n' +
          'Use `/help` or `/workflows` to see available commands.',
      );
      return {};
    }

    // Normalise input
    const normalised = rawName.startsWith('bmad-') ? rawName : `bmad-${rawName}`;
    const command = this.registry.resolve(normalised) || this.registry.resolve(rawName);

    if (!command) {
      return this.handleCommandNotFound(rawName, stream);
    }

    return this.executeCommand(command, userInput, request, stream, token);
  }

  /* -------------------------------------------------------------- */
  /*  /agents, /workflows, /tasks ‚Äî Listing views                   */
  /* -------------------------------------------------------------- */

  /** Handle `/agents` ‚Äî list installed agents. */
  private handleAgents(
    state: RegistryState,
    stream: vscode.ChatResponseStream,
  ): vscode.ChatResult {
    if (state.agents.length === 0) {
      stream.markdown('No BMAD agents installed.');
      return {};
    }

    const lines = ['# Installed BMAD Agents\n'];
    const byModule = new Map<string, typeof state.agents>();
    for (const a of state.agents) {
      const mod = a.module || 'core';
      if (!byModule.has(mod)) byModule.set(mod, []);
      byModule.get(mod)!.push(a);
    }

    for (const [mod, group] of byModule) {
      lines.push(`## Module: \`${mod}\`\n`);
      lines.push('| Agent | Persona | Title | Run Command |');
      lines.push('|---|---|---|---|');
      for (const a of group) {
        const slashName = mod === 'core'
          ? `bmad-agent-${a.name}`
          : `bmad-agent-${mod}-${a.name}`;
        lines.push(
          `| ${a.name} | ${a.displayName || '‚Äî'} | ${a.icon || ''} ${a.title || ''} | \`/run ${slashName}\` |`,
        );
      }
      lines.push('');
    }
    stream.markdown(lines.join('\n'));
    return {};
  }

  /** Handle `/workflows` ‚Äî list installed workflows. */
  private handleWorkflows(
    state: RegistryState,
    stream: vscode.ChatResponseStream,
  ): vscode.ChatResult {
    if (state.helpEntries.length === 0 && state.workflows.length === 0) {
      stream.markdown('No BMAD workflows installed.');
      return {};
    }

    const lines = ['# Installed BMAD Workflows\n'];

    if (state.helpEntries.length > 0) {
      const byPhase = new Map<string, typeof state.helpEntries>();
      for (const h of state.helpEntries) {
        const phase = h.phase || 'anytime';
        if (!byPhase.has(phase)) byPhase.set(phase, []);
        byPhase.get(phase)!.push(h);
      }

      for (const [phase, entries] of byPhase) {
        lines.push(`## ${phase}\n`);
        lines.push('| Run Command | Name | Agent | Required | Description |');
        lines.push('|---|---|---|---|---|');
        for (const h of entries) {
          const cmd = h.command ? `\`/run ${h.command}\`` : '*‚Äî*';
          const req = h.required === 'true' ? '‚úÖ' : '';
          lines.push(`| ${cmd} | ${h.name} | ${h['agent-title'] || ''} | ${req} | ${h.description} |`);
        }
        lines.push('');
      }
    } else {
      lines.push('| Name | Module | Description | Run Command |');
      lines.push('|---|---|---|---|');
      for (const w of state.workflows) {
        const slashName = `bmad-${w.module}-${w.name}`;
        lines.push(`| ${w.name} | ${w.module} | ${w.description} | \`/run ${slashName}\` |`);
      }
    }
    stream.markdown(lines.join('\n'));
    return {};
  }

  /** Handle `/tasks` ‚Äî list installed tasks and tools. */
  private handleTasks(
    state: RegistryState,
    stream: vscode.ChatResponseStream,
  ): vscode.ChatResult {
    if (state.tasks.length === 0 && state.tools.length === 0) {
      stream.markdown('No BMAD tasks or tools installed.');
      return {};
    }

    const lines = ['# Installed BMAD Tasks & Tools\n'];

    if (state.tasks.length > 0) {
      lines.push('## Tasks\n');
      lines.push('| Name | Module | Description |');
      lines.push('|---|---|---|');
      for (const t of state.tasks) {
        lines.push(`| ${t.name} | ${t.module} | ${t.description} |`);
      }
      lines.push('');
    }

    if (state.tools.length > 0) {
      lines.push('## Tools\n');
      lines.push('| Name | Module | Description |');
      lines.push('|---|---|---|');
      for (const t of state.tools) {
        lines.push(`| ${t.name} | ${t.module} | ${t.description} |`);
      }
    }
    stream.markdown(lines.join('\n'));
    return {};
  }

  /* -------------------------------------------------------------- */
  /*  Free text handler                                             */
  /* -------------------------------------------------------------- */

  /**
   * Handle free-text (no slash command).
   *
   * 1. If it starts with `bmad-`, try exact match ‚Üí execute.
   * 2. Otherwise, send to LLM with BMAD workspace context.
   */
  private async handleFreeText(
    state: RegistryState,
    request: vscode.ChatRequest,
    stream: vscode.ChatResponseStream,
    token: vscode.CancellationToken,
  ): Promise<vscode.ChatResult> {
    const prompt = request.prompt.trim();

    // Try exact command match
    if (prompt.startsWith('bmad-')) {
      const firstWord = prompt.split(/\s+/)[0];
      const command = this.registry.resolve(firstWord);
      if (command) {
        const userInput = prompt.slice(firstWord.length).trim();
        return this.executeCommand(command, userInput, request, stream, token);
      }
    }

    // General BMAD-aware conversation
    const contextPrompt = [
      'You are an expert on the BMAD-METHOD framework.',
      `This workspace has BMAD installed with modules: ${state.modules.join(', ')}.`,
      `There are ${state.commands.size} commands available.`,
      '',
      'The user is asking a question in the context of their BMAD project.',
      'If their question relates to a specific workflow, agent, or task,',
      'suggest the appropriate `@bmad /run <command>` command.',
      '',
      `User: ${prompt}`,
    ].join('\n');

    return this.sendToLlm(contextPrompt, request, stream, token);
  }

  /* -------------------------------------------------------------- */
  /*  Command execution (Prompt File Executor)                      */
  /* -------------------------------------------------------------- */

  /**
   * Execute a resolved BMAD command by reading its official prompt
   * file and sending it directly to the LLM.
   *
   * **Resolution order:**
   * 1. `command.promptFilePath` ‚Äî official `.prompt.md` / `.agent.md`
   * 2. `state.promptFiles` ‚Äî prompt file map from scan
   * 3. `BmadRuntime` ‚Äî @deprecated fallback for installs without
   *    `--tools github-copilot`
   *
   * The prompt body is passed **as-is** ‚Äî no file inlining, no
   * `{project-root}` resolution. The LLM reads workspace files
   * through its own context, matching native Copilot behaviour.
   */
  private async executeCommand(
    command: BmadCommand,
    userInput: string,
    request: vscode.ChatRequest,
    stream: vscode.ChatResponseStream,
    token: vscode.CancellationToken,
  ): Promise<vscode.ChatResult> {
    const workspaceRoot = this.getWorkspaceRoot();

    stream.markdown(
      `üöÄ **Executing**: \`${command.slashName}\`  ‚Üí  CLI: \`${command.cliSyntax}\`\n` +
        `> ${command.description}\n\n---\n\n`,
    );

    // 1. Try official prompt file
    const promptFilePath = command.promptFilePath
      || this.registry.state?.promptFiles.get(command.slashName);

    if (promptFilePath && fs.existsSync(promptFilePath)) {
      this.log(`Using prompt file: ${promptFilePath}`);
      const compiledPrompt = this.buildFromPromptFile(promptFilePath, userInput);
      return this.sendToLlm(compiledPrompt, request, stream, token);
    }

    // 2. Fallback: BmadRuntime prompt builder
    this.log(`No prompt file for ${command.slashName}, falling back to BmadRuntime`);
    const state = this.registry.state!;
    const runtime = new BmadRuntime(workspaceRoot, state);
    const fallbackPrompt = runtime.buildPrompt(command, userInput);
    return this.sendToLlm(fallbackPrompt, request, stream, token);
  }

  /**
   * Read an official `.prompt.md` or `.agent.md` file, strip YAML
   * frontmatter, and return the body **as-is**.
   *
   * No file inlining, no `{project-root}` resolution, no token
   * management. The official prompt is passed directly to the LLM,
   * matching the behaviour of native GitHub Copilot.
   *
   * @param filePath  - Absolute path to the prompt file.
   * @param userInput - Additional user input to append.
   * @returns Prompt body ready to send to the LLM.
   */
  private buildFromPromptFile(
    filePath: string,
    userInput: string,
  ): string {
    const raw = fs.readFileSync(filePath, 'utf8');

    // Strip YAML frontmatter (--- ... ---)
    const fmMatch = raw.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n([\s\S]*)$/);
    const body = fmMatch ? fmMatch[2] : raw;

    // Compose final prompt ‚Äî body as-is + optional user input
    if (userInput) {
      return `${body}\n\n## Additional User Input\n\n${userInput}`;
    }

    return body;
  }

  /* -------------------------------------------------------------- */
  /*  Command not found                                             */
  /* -------------------------------------------------------------- */

  /** Show a "not found" message with fuzzy suggestions. */
  private handleCommandNotFound(
    rawName: string,
    stream: vscode.ChatResponseStream,
  ): vscode.ChatResult {
    const suggestions = this.registry.search(rawName, 5);
    if (suggestions.length > 0) {
      const list = suggestions
        .map((s) => `- \`/run ${s.slashName}\` ‚Äî ${s.description}`)
        .join('\n');
      stream.markdown(
        `‚ùì Command \`${rawName}\` not found.\n\nDid you mean:\n${list}`,
      );
    } else {
      stream.markdown(
        `‚ùì Command \`${rawName}\` not found.\n\n` +
          'Use `/workflows` to see all available commands, or `/install` to set up BMAD.',
      );
    }
    return {};
  }

  /** Format detailed info for a single command. */
  private formatCommandDetail(cmd: BmadCommand): string {
    const lines = [
      `## \`${cmd.slashName}\`\n`,
      `- **CLI syntax:** \`${cmd.cliSyntax}\``,
      `- **Category:** ${cmd.category}`,
      `- **Module:** ${cmd.module}`,
      `- **Description:** ${cmd.description}`,
    ];
    if (cmd.agentTitle) lines.push(`- **Agent:** ${cmd.agentTitle}`);
    if (cmd.promptFilePath) lines.push(`- **Prompt file:** \`${cmd.promptFilePath}\``);
    lines.push(`\n**Run:** \`@bmad /run ${cmd.slashName}\``);
    return lines.join('\n');
  }

  /* -------------------------------------------------------------- */
  /*  LLM interaction                                               */
  /* -------------------------------------------------------------- */

  /**
   * Send a prompt to the Copilot LLM and stream the response.
   *
   * Uses `request.model.sendRequest()` to respect the user's
   * selected model preference.
   */
  private async sendToLlm(
    prompt: string,
    request: vscode.ChatRequest,
    stream: vscode.ChatResponseStream,
    token: vscode.CancellationToken,
  ): Promise<vscode.ChatResult> {
    const messages = [vscode.LanguageModelChatMessage.User(prompt)];

    try {
      const chatResponse = await request.model.sendRequest(messages, {}, token);

      for await (const fragment of chatResponse.text) {
        if (token.isCancellationRequested) break;
        stream.markdown(fragment);
      }
    } catch (err) {
      if (err instanceof vscode.LanguageModelError) {
        this.log(`LLM error: ${err.message} (code: ${err.code})`);
        const msg = err.code === 'quota'
          ? '\n\n‚ö†Ô∏è **Rate limit reached.** Please wait a moment and try again.'
          : `\n\n‚ö†Ô∏è **Model error**: ${err.message}`;
        stream.markdown(msg);
      } else {
        throw err;
      }
    }

    return {};
  }

  /* -------------------------------------------------------------- */
  /*  Utilities                                                     */
  /* -------------------------------------------------------------- */

  /** Get the first workspace folder path. */
  private getWorkspaceRoot(): string {
    const folders = vscode.workspace.workspaceFolders;
    if (!folders || folders.length === 0) {
      throw new Error('No workspace folder is open.');
    }
    return folders[0].uri.fsPath;
  }

  /** Write a timestamped log line. */
  private log(message: string): void {
    const ts = new Date().toISOString();
    this.outputChannel.appendLine(`[${ts}] [ChatBridge] ${message}`);
  }
}


